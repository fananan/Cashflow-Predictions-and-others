---
title: "Cashflow Prediction Project"
author: "Fan"
date: "May 7, 2017"
output: html_document
---

```{r data cleaning, include=FALSE}
#read the file
if ("package:readxl" %in% search()) { detach("package:readxl", unload=TRUE) }
if ("readxl" %in% rownames(installed.packages())) { remove.packages("readxl") }
install.packages("readxl")
library(readxl)
data<-read_excel("/Users/fanliu/Desktop/final\ dataset\ copy.xlsx")  #data need to be cleaned and collected first
View(data)
attach(data)

#sum up project amount
totalamt<-tapply(projectamt,factor(projectpath),sum)
class(totalamt)
##try another way to sum total amount 
library(plyr)
?ddply #Split data frame, apply function, and return results in a data frame.
totalamt<-ddply(data,"projectpath",summarise,sum(projectamt)) #works!!
colnames(totalamt)[2]<-"totalamt"
?ddply
write.csv(totalamt, file = "totalamt")
?write.csv

#combine the address together
final<-read_excel("/Users/fanliu/Desktop/final\ dataset.xlsx")
final$location<-paste(final$street1, final$street2, final$city, final$state,sep = ",")
write.csv(final, file="finals")

#to figure out why 163 and 173
a163<-read_excel("/Users/fanliu/Desktop/163\ projects\ with\ project\ duration.xlsx") #you can't use number as assignment
a173<-read_excel("/Users/fanliu/Desktop/173\ project\ duration.xlsx")
a<-unique(a163$projectpath)
b<-unique(a173$ProjectPath)
write.csv(a, file="a")

dataset<-read_excel("/Users/fanliu/Desktop/dataset.xlsx")
path<-unique(dataset$projectpath)
write.csv(path,file = "path")

sfdata<-read_excel("/Users/fanliu/Desktop/data\ from\ Salesforce.xlsx")
projectpath<-unique(sfdata$projectpath)
write.csv(projectpath,file = "projectpath")

#deduplicate the projectpath
sfdata$sf<-with(sfdata,paste(sfdata$firmcode,sfdata$projectpath,sfdata$projectname,sep=";")) #only paste can have the option that you can separate variables by comma
View(sfdata)
(uni_sfdata<-unique(sfdata$sf))
write.csv(uni_sfdata,file = "uni_sfdata")

#process match data
match<-read_excel("/Users/fanliu/Desktop/match\ project.xlsx")
#this ! seems like no use to remove certain rows..
match1<-match[!(match$ProjectName_SF=="NA"),]
match2<-na.omit(match1)
write.csv(match2,file = "matchproject")

#when you wanna delete certain rows, try subset

#process deposit data
library(readxl)
deposit<-read_excel("deposit.xlsx")
#deposit<-deposit[complete.cases(deposit),]
#great!! use complete.cases to delete the rows with NA
deposit$projectpath<-substr(deposit$projectpath,1,5)



#first, change 0001 stick to the number to the number:
for (i in 1:(length(deposit$projectpath)-1)){
  if ((!is.na(deposit$projectpath[i])) && (deposit$projectpath[i+1]=="0001"))  #the second one has error...
 #you can't test NA in ==NA, the only way to test NA is is.na()
#when you do the next value is assigned by the last value, be careful of the total number of rows...
    deposit$projectpath[i+1]=deposit$projectpath[i]
  else
    deposit$projectpath[i+1]=deposit$projectpath[i+1]
}
#always the error:Error in if (is.na(deposit$projectpath[i] == FALSE) && (deposit$projectpath[i +  : missing value where TRUE/FALSE needed
#fail..manually change it..

View(deposit)
#SUBSET!!!!! to remove rows under the certain criteria
deposit<-deposit[complete.cases(deposit),]
#remove the 001 first
deposit<-subset(deposit,projectpath!="0001")
deposit<-deposit[order(deposit$projectpath),]
write.csv(deposit,file = "deposit_final")

list<-list(1,2,3,4,5)
lapply(list,"*",3)



#substrings of a character, it is more powerful than EXCEL Left()
deposit$projectpath<-substr(deposit$projectpath, 1,5)
#group deposite and amount by path
#wait....feels like you can't delete the path=NA, cuz it is kind of keeping accounts
#the only thing you need to do is to group them..
write.csv(deposit, file = "updated_deposite")

#delete the redundant rows i invoice
invoice<-read_excel("invoice.xlsx")
invoice<-invoice[order(invoice$projectpath),]
write.csv(invoice,file = "invoice_final")
#change amount =0 to amount =NA
invoice$invoiceamt[invoice$invoiceamt==0]=NA   #remember this syntax
invoice<-invoice[complete.cases(invoice),]
invoice$invoicedate<-substr(invoice$invoicedate,1,10)


write.csv(invoice,file = "invoice")


#now use the max date-min to simplify the payment days issue
days<-read_excel("days.xlsx")
days<-days[order(days$path),]
View(days)
class(days$path)
uni_path<-unique(days$path)  #why it is 583 again....



diffdays<-rep(NA,583)

for (i in 1:length(uni_path)){
  diffdays[i]<-as.numeric(max(days$date[days$path==uni_path[i]])-min(days$date[days$path==uni_path[i]]))  #change difftime class to numeric
}

paymentdays<-cbind.data.frame(uni_path,diffdays)
write.csv(paymentdays,file="paymentdays")

#solved: test 14019 (the result is 0, weird)
which(uni_path==14019) #get the position of a number in an vector
as.numeric(max(days$date[days$path==uni_path[248]])-min(days$date[days$path==uni_path[248]])) #not 0; 78
diffdays[248]
#ok.....the code has no problem...you misread 14109 as 14019....be careful

#test if the path only has one date. check

#test if there are only invoice dates, no deposite dates and vice versa. cuz under this situation, even though the resaults are non-zero, they are also wrong
depositpath<-read_excel("depositpath.xlsx")
invoicepath<-read_excel("invoicepath.xlsx")
depositpath<-unique(depositpath)
invoicepath<-unique(invoicepath)
write.csv(depositpath,file = "depositpath")
write.csv(invoicepath,file = "invoicepath")

#latest number of projects check:
cv<-read_excel("/Users/fanliu/Desktop/latest\ clearview\ client\ inquiry.xlsx")
cv_path<-unique(cv$projectpath)
cv_path[order(cv_path)]

#process cvdata to import in analysis dataset draft:
cvdata<-read_excel("cvdata.xlsx")
library(dplyr)
library(tidyverse)
cvdata<-cvdata %>%
  unite(new,projectpath,firmname,street1,street2,city,state,zip,sep=";")
View(cvdata)
cvdata<-unique(cvdata)
write.csv(cvdata,file = "cvdata_update")

#extract only useful data from invoice and deposit
invoice<-read_excel("invoice.xlsx")
path<-read_excel("path.xlsx")
invoice<-data.frame(invoice)
path<-data.frame(path)
(p<-path$Path)
View(invoice)
invoice[invoice$projectpath==p,]
#fail... how to match a col that it is repeated in another report
#!! use conditional formatting in excel, even though you can't delete them, but you can see which ones you don't need to match
#excel is reall powerful, except do the modeling, you can use excel to do everything





#calculate the real paymentdays: 
library(readxl)
data<-read_excel("finallly.xlsx")
View(data)
data<-subset(data,is.na(data$paymentdays)==FALSE) #YES!

#and then average each projectpath paymentdays
class(data$projectpath)
data$projectpath<-as.character(data$projectpath)
finalpay<-data.frame(tapply(data$paymentdays,data$projectpath,mean))
class(finalpay)
dim(finalpay)
View(finalpay)
write.csv(finalpay,file = "finalpay")

#start over .....cuz you need to not only remove NA values, but also negative values too
#consider median and mean???????
library(readxl)
data<-read_excel("finallly.xlsx")
View(data)
data<-subset(data,is.na(data$paymentdays)==FALSE)
#remove negative value
data<-subset(data,data$paymentdays>=0)

class(data$projectpath)
data$projectpath<-as.character(data$projectpath)
finalpay<-data.frame(tapply(data$paymentdays,data$projectpath,mean))
#to tell when to use median or mean is time-consuming....???????????????！！！NO, i'll defintely use mean, cuz our purpose is not to get accurate avegrage number, every invoice record especially payment days are so large that can be seen as "outlier" in calculation perspective, we typically need to keep it around.
finalpay
write.csv(finalpay,file = "finalpay")

#start over again....cuz some typos in invoice_final (you enter amount in invoice data,so payment days are unbelievably large...)
#i've done remove NA and negative in excel
data<-read_excel("finallly.xlsx")
View(data)
#but there are still blank
data<-subset(data,is.na(data$paymentdays)==FALSE)
data$projectpath<-as.character(data$projectpath)
finalpay<-data.frame(tapply(data$paymentdays,data$projectpath,mean))
write.csv(finalpay,file = "finalpay")

#if you do it in median
finalpay_median<-data.frame(tapply(data$paymentdays,data$projectpath,median))
write.csv(finalpay_median,file = "finalpay_median")

#process data for time series model
#table 1
raw<-read_excel("raw\ data.xlsx")
raw<-raw[order(raw$depositdate),]
View(raw)
raw<-raw[-(1:8),]
raw<-raw[-(2153:2156),]
raw$depositdate<-substr(raw$depositdate,1,7)
raw<-data.frame(tapply(raw$amount,raw$depositdate,sum))

write.csv(raw,file = "raw")

raw<-t(raw)
write.csv(raw,file = "table 1")

t3<-read_excel("3.xlsx")
t3<-t(t3)
write.csv(t3,file = "t3")



#ts for R
ts<-read_excel("ts\ for\ R.xlsx")
View(ts)

ts<-ts(ts,frequency=12)
plot.ts(ts)
logts<-log(ts)
plot.ts(logts)

plot(diff(logts,12))
install.packages("tseries")
library(tseries)
adf.test(logts,alternative = "stationary")

install.packages("forecast")
library(forecast)
frequency(logts)
nsdiffs(logts)

logdiff12=diff(logts,lag=12)
logdiff12=diff(logdiff12,lag=12)
plot(logdiff12)
acf(logdiff12)
pacf(logdiff12)


?Box.test
Box.test(logdiff12,lag=1,type="Ljung-Box")
adf.test(logdiff12,alternative = "stationary")

#if you wanna get which paths aren't used, you can use vlooup in excel...

#ok, i'll write a loop to realize it, you need to use. reference from bayesian 
#total<-rep(NA,582)
##the problem: can we use "totalamt" as our project total amount? or the one in Salesforce


#create dashboards. EWWWWW, i went for excel for the default interactive default
#i'll make the amount of won opportunities unit first in the right side
#and Put amount billed and received unit on the left side
DB<-read_excel("DashBoard.xlsx")

library(readxl)
New<-read_excel("New.xlsx")
New<-tapply(New$paymentdays,New$`Account Name`,median)
New<-data.frame(New)
write.csv(New,file = "Median")

list<-read_excel("list.xlsx")
list<-list[,-2]

list<-split(list,list$`Account Name`)  #for a list, be careful of the sequence!! dataset is the first
nrow(list[[1]])
avg<-rep(NA,38)
for (i in 1:38){
  if(nrow(list[[i]])>1){
    avg[i]<-mean(head(list[[i]]$paymentdays,-1))
  }
  else
  {avg[i]<-NA}
}

x<-c(1,2,3)
head(x,-1) #this is how you delete the last one
tail(x,1)
avg

last<-rep(NA,38)
for (i in 1:38){
  last[i]<-tail(list[[i]]$paymentdays,1)
}
last

avg<-avg[-1]
last<-last[-1]

#error rate
error<-(avg-last)/last
error<-error[-9]
mean(error)
#[1] 1.387734


#try the median
median<-rep(NA,38)
for (i in 1:38){
  if(nrow(list[[i]])>1){
    median[i]<-median(head(list[[i]]$paymentdays,-1))
  }
  else
  {median[i]<-NA}
}

median<-median[-1]


#error rate
error<-(median-last)/last
error<-error[-9]
mean(error)
#[1] 1.02764

plot(last, col="black")
par(new=T) #tells R to make the second plot without cleaning the first. Put two vectors together in the same plot...
plot(avg,col="red")



#fill the matrix using loop
Amount<-read_excel("Amount.xlsx")
Rate<-read_excel("Rate.xlsx")
library(car)
View(Amount)
class(Amount)
Amount$Amount<-recode(Amount$Amount,"NA=0")
View(rate)
length(Rate$`Hit Ratio`)
length(Amount$Amount)

x=matrix(data=NA, nrow=1752,ncol=53)


for (i in 1:1752){
  for (j in 1:53){
    x[i,j]=Amount$Amount[i]*Rate$`Hit Ratio`[j]
  }
}

View(x)
write.csv(x,file = "Amount with hit rate")

#dates manipulation; SUM by month
library(lubridate)
date("2014-03-16"+7)
library(readxl)
close<-read_excel("date.xlsx")
View(close)
close$`Close Date`
close$`Close Date`<-substr(close$`Close Date`,1,10)
table<-matrix(data=NA, nrow = 1752, ncol = 53)
days<-seq(7,7*53,by=7)
?seq
c<-date(date(close$`Close Date`[1])+days[1])
c

for (i in 1:1752){
  for (j in 1:53){
    table[i,j]=as.character(date(close$`Close Date`[i])+days[j])  #!!!there is some format issue if you don't mark it as "character", even if this issue doesn't appear in single example.... 
  }
}

View(table)
table<-substr(table,1,7)

amt<-read_excel("Amount.xlsx")
View(amt)
amt<-data.frame(amt)
amt<-amt[,-1]
table<-data.frame(table)
colnames(table)
colnames(amt)<-colnames(table)

#只要把他们变成一个vector，变成一行就行
m<-matrix(c(1,2,3,4,5,6,7,8), nrow = 2, ncol = 4)
as.vector(m)

amt<-as.matrix(amt)
View(amt)
amt<-na.omit(amt)
v_amt<-as.vector(amt)
length(v_amt)

v_table<-as.vector(as.matrix(table))
length(v_table)

a<-cbind(v_amt,v_table)
a<-data.frame(a)
a$v_amt<-as.numeric(a$v_amt)
sum<-tapply(a$v_amt,a$v_table,sum)
sum<-data.frame(sum)
write.csv(sum,file = "sum by month")

#今天做完sum by month真的很有成就感，enjoy自己怎么解决问题的思路，真的用到大量数据的时候，还是r快和方便

#it can't be that many projects we can get in each month, so sample the dataset
head(v_table,500)
#count the number of elements in a vector
table(v_table) #it's impossible that we can get thousand opportunities per month
issued<-read_excel("issued.xlsx")
View(issued)
issued<-data.frame(issued)
issued$Proposal.Issued<-substr(issued$Proposal.Issued,1,7)
t_date<-table(issued$Proposal.Issued) #this is real how many open proposals we get for each month....

class(issued$Stage)
issued$Stage<-as.character(issued$Stage)

list<-split(issued,issued$Proposal.Issued)
hit<-rep(NA,88)

for (i in 1:88){
  hit[i]<-length(which(list[[i]][,2]=="Closed Won"))/(1752-length(which(list[[i]][,2]==c("Closed Won","Closed Lost"))))
}

nrow(list[[4]])
length(which(list[[4]][,2]=="Closed Won"))/nrow(list[[4]])   #how you count the number of rows that is "closed won"

#total proposals are 1752










class(hit)
uni<-unique(issued$Proposal.Issued)
month<-uni[order(uni)]
class(month)

hit_month<-cbind(month,hit)
write.csv(hit_month,file = "hit_month")

issued2<-read_excel("issued.xlsx")
View(issued2)
issued2<-data.frame(issued2)
issued2$Proposal.Issued<-substr(issued2$Proposal.Issued,1,7)
library(car)
issued2$Amount<-recode(issued2$Amount,"NA=0")
sum_month<-data.frame(tapply(issued2$Amount,issued2$Proposal.Issued,sum))
colnames(sum_month)<-"sum_amount"
length(sum_month$sum_amount)

cash<-sum_month$sum_amount*hit
write.csv(cash,file = "cash")

#use hit rate and number of proposals/month to do the prediction (sampling the amount number from the dataset 1752)
hit_month<-data.frame(hit_month)
avg_hit<-read_excel("Avg_hit.xlsx")
length(avg_hit$Avg_hit)  
t_date<-data.frame(t_date)
t_date$Var1<-substr(t_date$Var1,6,7)
proposal_month<-data.frame(tapply(t_date$Freq,t_date$Var1,mean))
colnames(proposal_month)<-"No.prop"
proposal_month$No.prop<-round(proposal_month$No.prop) #all proposals 
proposal_month<-as.vector(proposal_month) 
View(proposal_month)
length(proposal_month$No.prop) ######12

year_pred<-rep(NA,12)
sample<-data.frame(matrix(data=NA,12,500))

for (i in 1:12){
  for (j in 1:500){
  sample[i,j]<-sum(sample(issued2$Amount,proposal_month$No.prop[i]))
}
  year_pred[i]<-rowMeans(sample)[i]*avg_hit$Avg_hit[i]
}
?sample
year_pred

write.csv(year_pred,file = "month_pred")

c<-data.frame(matrix(c(1,2,3,4,4,6,5,7.8,3,4,6,3,5,4,5,3),4,4))

#the trend of won% in each month
View(issued)
library(plyr)
?count
c<-count(issued,c("Proposal.Issued","Stage"))
class(c)
c[-c(which(issued$Stage=="Proposal/Price Quote")),] #so weird..which can't count all numbers in a dataset..

sum(issued$Stage=="Closed Won")#590
sum(issued$Stage=="Closed Lost") #1021
#total closed proposals=590+1021=1611

hit1<-rep(NA,88)
#the issued dataset before didn't include "amount", so here the stage is on the 3rd column. 
list<-split(issued,issued$Proposal.Issued)
for (i in 1:88){
  if(i==1){
    denom[i]<-1611
    hit1[i]<-length(which(list[[i]][,3]=="Closed Won"))/denom[i]
  }
  else{
    denom[i]<-denom[i-1]-length(which(list[[i-1]][,3]=="Closed Won"))-length(which(list[[i-1]][,3]=="Closed Lost"))
    hit1[i]<-length(which(list[[i]][,3]=="Closed Won"))/denom[i]
  }
}


nrow(list[[8]])
length(which(list[[8]][,3]=="Closed Won")) #so you can only separate the name to make it right, not to combine them together
length(which(list[[8]][,3]=="Closed Won")) #length can be seen as count~~

which(list[[6]][,3]=="Closed Won")
list

hit1 #this hit is all months spreaded in each recorded year




issued2<-read_excel("issued.xlsx")
View(issued2)
issued2$`Proposal Issued`<-substr(issued2$`Proposal Issued`,6,7)

list<-split(issued2,issued2$`Proposal Issued`)
hit2<-rep(NA,12) #only twleve months

#the issued dataset before didn't include "amount", so here the stage is on the 3rd column. 
denom<-rep(NA,12)

for (i in 1:12){
  if(i==1){
    denom[i]<-1611
    hit2[i]<-length(which(list[[i]][,3]=="Closed Won"))/denom[i]
  }
  else{
    denom[i]<-denom[i-1]-length(which(list[[i-1]][,3]=="Closed Won"))-length(which(list[[i-1]][,3]=="Closed Lost"))
    hit2[i]<-length(which(list[[i]][,3]=="Closed Won"))/denom[i]
  }
}

hit2  #hit rate by month
for (i in 1:12){
  list[[i]]<-data.frame(list[[i]])
}
length(which(list[[1]]$Stage=="Closed Won"))
51/1611
length(which(list[[2]]$Stage=="Closed Won"))
length(which(list[[1]]$Stage=="Closed Lost"))
58/(1611-79-51)
#this hit rate is correct
#recalculate the number of proposals by month
t_date<-table(issued$Proposal.Issued)
t_date<-data.frame(t_date)
t_date$Var1<-substr(t_date$Var1,6,7)
proposal_month<-data.frame(tapply(t_date$Freq,t_date$Var1,mean))
colnames(proposal_month)<-"No.prop"
proposal_month$No.prop<-round(proposal_month$No.prop) #all proposals 
View(proposal_month)
length(proposal_month$No.prop) ######12

#recode NA =0
library(car)
issued2$Amount<-recode(issued2$Amount,"NA=0")


year_pred<-rep(NA,12)
sample<-data.frame(matrix(data=NA,12,500))

for (i in 1:12){
  for (j in 1:500){
   sample[i,j]<-sum(sample(issued2$Amount,proposal_month$No.prop[i]))
}
  year_pred[i]<-rowMeans(sample)[i]*hit2
}

year_pred #just 5 digits, don't make sense. so the problem is hit rate


#if you only calculate each month : closed won / (closed won+closed lost)
hit3<-rep(NA,12)
for (i in 1:12){
    hit3[i]<-length(which(list[[i]][,3]=="Closed Won"))/(length(which(list[[i]][,3]=="Closed Won"))+length(which(list[[i]][,3]=="Closed Lost")))
}

hit3

year_pred<-rep(NA,12)
sample<-data.frame(matrix(data=NA,12,500))

for (i in 1:12){
  for (j in 1:500){
   sample[i,j]<-sum(sample(issued2$Amount,proposal_month$No.prop[i]))
}
  year_pred[i]<-rowMeans(sample)[i]*hit3
}

year_pred  #this is normal each month goal

#it's better to average each month hit rate, rather than gather each month proposal status together and then calculate the average, cuz the proposals in each year will not be seen the same in each month
issued<-read_excel("issued.xlsx")
View(issued)
issued$`Proposal Issued`<-substr(issued$`Proposal Issued`,1,7)
list<-split(issued,issued$`Proposal Issued`)


#start over
denom<-rep(NA,88)
hit2<-rep(NA,88)

for (i in 1:88){
  if(i==1){
    denom[i]<-1611
    hit2[i]<-length(which(list[[i]][,3]=="Closed Won"))/denom[i]
  }
  else{
    denom[i]<-denom[i-1]-length(which(list[[i-1]][,3]=="Closed Won"))-length(which(list[[i-1]][,3]=="Closed Lost"))
    hit2[i]<-length(which(list[[i]][,3]=="Closed Won"))/denom[i]
  }
}

hit2  #hit rate by month
uni<-unique(issued$`Proposal Issued`)
month<-uni[order(uni)]
class(month)

hit2_month<-cbind.data.frame(month,hit2) 
class(hit2_month$hit2)
class(hit2_month$month)
class(issued2$`Proposal Issued`)
hit2_month$month<-as.character(hit2_month$month)
hit2_month$month<-substr(hit2_month$month,6,7)
View(hit2_month)
hit2<-data.frame(tapply(hit2_month$hit2,hit2_month$month,mean))
colnames(hit2)<-"hit rate"

t(hit2)



#recalculate the number of proposals by month
t_date<-table(issued$Proposal.Issued)
t_date<-data.frame(t_date)
t_date$Var1<-substr(t_date$Var1,6,7)
proposal_month<-data.frame(tapply(t_date$Freq,t_date$Var1,mean))
colnames(proposal_month)<-"No.prop"
proposal_month$No.prop<-round(proposal_month$No.prop) #all proposals 
View(proposal_month)
length(proposal_month$No.prop) ######12

#recode NA =0
library(car)
issued$Amount<-recode(issued$Amount,"NA=0")


year_pred1<-rep(NA,12)
sample<-data.frame(matrix(data=NA,12,500))

for (i in 1:12){
  for (j in 1:500){
   sample[i,j]<-sum(sample(issued$Amount,proposal_month$No.prop[i]))
}
  year_pred1[i]<-rowMeans(sample)[i]*hit2$`hit rate`
}
#why year_pred is becoming a list..?

year_pred1 #just 5 digits, don't make sense. so the problem is hit rate


#if you only calculate each month : closed won / (closed won+closed lost)
list<-split(issued,issued$Proposal.Issued)
hit3<-rep(NA,88)
for (i in 1:88){
    hit3[i]<-length(which(list[[i]][,3]=="Closed Won"))/(length(which(list[[i]][,3]=="Closed Won"))+length(which(list[[i]][,3]=="Closed Lost")))
}

hit3

uni<-unique(issued$`Proposal Issued`)
month<-uni[order(uni)]
class(month)

hit3_month<-cbind.data.frame(month,hit3) 
hit3_month$month<-as.character(hit3_month$month)
hit3_month$month<-substr(hit3_month$month,6,7)
View(hit3_month)
hit3<-data.frame(tapply(hit3_month$hit3,hit3_month$month,mean))
colnames(hit3)<-"hit rate"

t(hit3)

year_pred2<-rep(NA,12)
sample<-data.frame(matrix(data=NA,12,500))

for (i in 1:12){
  for (j in 1:500){
   sample[i,j]<-sum(sample(issued$Amount,proposal_month$No.prop[i]))
}
  year_pred2[i]<-rowMeans(sample)[i]*hit3$`hit rate`
}

year_pred2  #this is normal each month goal


#latest paymentdays
library(readxl)
data<-read_excel("paymentdays.xlsx")
data<-data.frame(data)
View(data)
data$path<-as.character(data$path)
tb<-data.frame(tapply(data$paymentdays,data$path,mean)) #tapply function canbe done by pivot table....
tb

write.csv(tb,file = "final paymentdays")  


```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```









## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
